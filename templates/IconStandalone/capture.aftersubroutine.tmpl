$prologue

SUBROUTINE ftg_${subroutine.name}_init_serializer(stage, dir)

  USE mo_impl_constants, ONLY: MAX_CHAR_LENGTH
  USE mo_mpi, ONLY: get_my_mpi_all_id
  USE m_ser_ftg, ONLY: ftg_set_serializer, ftg_add_serializer_metainfo, ftg_set_savepoint, ftg_add_savepoint_metainfo, ignore_bullshit_max_dim_size, ignore_bullshit_allow_negative_indices

  CHARACTER(*), INTENT(IN) :: stage, dir

  CHARACTER(len=MAX_CHAR_LENGTH) :: basename, mkdir_err

  WRITE (basename,'(A,A,A,I0.2)') 'ftg_${subroutine.name}_', TRIM(stage), '_', get_my_mpi_all_id()
  WRITE (0,'(A,A,A,I0)') 'FTG ROUND ', TRIM(basename), ' : ', ftg_${subroutine.name}_round
  WRITE (0,'(A)') 'FTG WRITE STARTED '//TRIM(basename)

  WRITE (0,*) 'FTG INIT ${subroutine.name} '//TRIM(basename)
  
  mkdir_err = ''
  CALL EXECUTE_COMMAND_LINE('mkdir -p '//TRIM(dir), cmdmsg=mkdir_err)
  IF (TRIM(mkdir_err) /= '') THEN
    WRITE (0,'(A,A)') 'FTG INIT *** ERROR: ', TRIM(mkdir_err)
  END IF 
  
  ignore_bullshit_max_dim_size = 100000
  ignore_bullshit_allow_negative_indices = .TRUE.
  
  CALL ftg_set_serializer(TRIM(dir), TRIM(basename), 'w')
  CALL ftg_add_serializer_metainfo('subroutine', '${subroutine.name}')
  CALL ftg_add_serializer_metainfo('stage', stage)
  CALL ftg_add_serializer_metainfo('mpi_rank', get_my_mpi_all_id())
  
  CALL ftg_set_savepoint(TRIM(stage))

END SUBROUTINE ftg_${subroutine.name}_init_serializer

SUBROUTINE ftg_${subroutine.name}_close_serializer(stage)

  USE mo_mpi, ONLY: get_my_mpi_all_id
  USE m_ser_ftg, ONLY: ftg_destroy_savepoint, ftg_destroy_serializer

  CHARACTER(*), INTENT(IN) :: stage

  CHARACTER(len=1024) :: basename
  
  WRITE (basename,'(A,A,A,I0.2)') 'ftg_${subroutine.name}_', TRIM(stage), '_', get_my_mpi_all_id()
  WRITE (0,'(A)') 'FTG WRITE FINISHED '//TRIM(basename)

  CALL ftg_destroy_savepoint()
  CALL ftg_destroy_serializer()

END SUBROUTINE ftg_${subroutine.name}_close_serializer

LOGICAL FUNCTION ftg_${subroutine.name}_capture_input_active()

  ftg_${subroutine.name}_capture_input_active =         &
    ftg_${subroutine.name}_capture_input_enabled .AND.  &
    ftg_${subroutine.name}_round .EQ. ftg_${subroutine.name}_capture_round

END FUNCTION ftg_${subroutine.name}_capture_input_active
  
SUBROUTINE ftg_${subroutine.name}_capture_input($commaList($args))

  USE mtime,   ONLY: calendarType
  USE m_ser_ftg, ONLY: ftg_write, ftg_register_only
  
  $globals.imports
  $types.imports

  ${args.specs(intent = 'in')}

  INTEGER :: ftg_d1, ftg_d2, ftg_d3, ftg_d4
  CHARACTER(len=256) :: ftg_name

  CALL ftg_${subroutine.name}_init_serializer('input', ftg_${subroutine.name}_input_dir)
  
  ! MTIME CALENDAR TYPE --> Remove this line if mtime is not used
  CALL ftg_write("ftg_mtime_calendar", calendarType())

  ! REQUIRED ARGUMENTS
  #for $var in $args.requireds.usedVariables
    $ftgWrite($var) $clearLine
  #end for

  ! OPTIONAL ARGUMENTS
  #for $arg in $args.optionals
    #if $arg.usedVariables
      IF (PRESENT($arg.name)) THEN
      #for $var in $arg.usedVariables
        $ftgWrite($var) $clearLine
      #end for 
      END IF
    #end if 
  #end for

  ! GLOBALS
  #for $var in $globals.usedVariables
    $ftgWrite($var) $clearLine 
  #end for

  CALL ftg_write("ftg_${subroutine.name}_round", ftg_${subroutine.name}_round)

  CALL ftg_${subroutine.name}_close_serializer('input')

END SUBROUTINE ftg_${subroutine.name}_capture_input

LOGICAL FUNCTION ftg_${subroutine.name}_capture_output_active()

  ftg_${subroutine.name}_capture_output_active =         &
    ftg_${subroutine.name}_capture_output_enabled .AND.  &
    ftg_${subroutine.name}_round .EQ. ftg_${subroutine.name}_capture_round

END FUNCTION ftg_${subroutine.name}_capture_output_active
  
SUBROUTINE ftg_${subroutine.name}_capture_output($commaList($args.allOut, $result))

  USE mo_mpi, ONLY: work_mpi_barrier
  USE mo_exception, ONLY: finish
  USE m_ser_ftg, ONLY: ftg_write, ftg_register_only

  $globals.imports
  $types.imports

  ${args.allOut.specs(intent = 'in', allocatable = False)}
  #if $subroutine.isFunction:
    ${result.spec(intent = 'in', allocatable = False)}
  #end if

  INTEGER :: ftg_d1, ftg_d2, ftg_d3, ftg_d4
  CHARACTER(len=256) :: ftg_name

  CALL ftg_${subroutine.name}_init_serializer('output', ftg_${subroutine.name}_output_dir)

  $resetRegistrations
  ! REQUIRED ARGUMENTS
  #for $var in $args.allOut.requireds.usedVariables
    $ftgWrite($var) $clearLine
  #end for
    
  ! OPTIONAL ARGUMENTS
  #for $arg in $args.allOut.optionals
    #if $arg.usedVariables
      IF (PRESENT($arg.name)) THEN
        #for $var in $arg.usedVariables
          $ftgWrite($var) $clearLine
        #end for 
      END IF
    #end if 
  #end for
  
  #if $subroutine.isFunction
    ! RESULT
    #for $var in $result.usedVariables
      $ftgWrite($var) $clearLine
    #end for
  #end if
  
  ! GLOBALS
  #for $var in $globals.usedVariables
    $ftgWrite($var) $clearLine
  #end for
  
  CALL ftg_write("ftg_${subroutine.name}_round", ftg_${subroutine.name}_round)

  CALL ftg_${subroutine.name}_close_serializer('output')
  
  CALL work_mpi_barrier()
  CALL finish('FTG EXIT', 'Output captured: ${subroutine.name}', 0)

END SUBROUTINE ftg_${subroutine.name}_capture_output
  
$epilogue