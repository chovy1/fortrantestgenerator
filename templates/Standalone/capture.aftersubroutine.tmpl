$prologue

SUBROUTINE ftg_${subroutine.name}_init_for_capture(stage, dir)

  USE mpi
  USE m_ser_ftg,         ONLY: ftg_set_serializer, ftg_add_serializer_metainfo, ignore_bullshit_max_dim_size, ignore_bullshit_allow_negative_indices

  CHARACTER(*), INTENT(IN) :: stage, dir

  INTEGER(kind=4) my_mpi_id, error
  CHARACTER(len=1024) :: basename, mkdirerr
  
  CALL MPI_COMM_RANK(MPI_COMM_WORLD, my_mpi_id, error)

  WRITE (basename,'(a,a,a,i0)') 'ftg_${subroutine.name}_', TRIM(stage), '_', my_mpi_id

  WRITE (0,*) 'FTG INIT ${subroutine.name} '//TRIM(basename), my_mpi_id

  mkdirerr = ''
  CALL EXECUTE_COMMAND_LINE('mkdir -p '//TRIM(dir), cmdmsg=mkdirerr)
  IF (TRIM(mkdirerr) /= '') THEN
    WRITE (0,*) 'FTG INIT *** ERROR: ', TRIM(mkdirerr)
  END IF 
  
  ignore_bullshit_max_dim_size = 100000
  ignore_bullshit_allow_negative_indices = .TRUE.
  
  CALL ftg_set_serializer(TRIM(dir), TRIM(basename), 'w')
  CALL ftg_add_serializer_metainfo('subroutine', '${subroutine.name}')
  CALL ftg_add_serializer_metainfo('stage', stage)
  CALL ftg_add_serializer_metainfo('mpi_id', my_mpi_id)

END SUBROUTINE ftg_${subroutine.name}_init_for_capture

LOGICAL FUNCTION ftg_${subroutine.name}_capture_input_active()

  ftg_${subroutine.name}_capture_input_active =       &
    ftg_${subroutine.name}_capture_input_enabled .AND.  &
    ftg_${subroutine.name}_round .EQ. ftg_${subroutine.name}_capture_round

END FUNCTION ftg_${subroutine.name}_capture_input_active
  
SUBROUTINE ftg_${subroutine.name}_capture_input(${args.joinNames})

  USE mpi
  USE m_ser_ftg, ONLY: ftg_set_savepoint, ftg_write, ftg_register_only, ftg_destroy_savepoint, ftg_destroy_serializer
  
  ${globals.imports}

  ${args.specs(intent = 'in')}

  INTEGER(kind=4) my_mpi_id, error
  INTEGER :: ftg_d1, ftg_d2, ftg_d3, ftg_d4
  CHARACTER(len=256) :: ftg_c

  IF (ftg_${subroutine.name}_capture_input_active()) THEN
    
    CALL MPI_COMM_RANK(MPI_COMM_WORLD, my_mpi_id, error)
    CALL ftg_${subroutine.name}_init_for_capture('input', ftg_${subroutine.name}_input_dir)
    CALL ftg_set_savepoint('input')

    WRITE (0,*) 'FTG ROUND ${subroutine.name} ', ftg_${subroutine.name}_round, my_mpi_id
    WRITE (0,*) 'FTG WRITE INPUT DATA ${subroutine.name}', my_mpi_id

    ! REQUIRED ARGUMENTS
    #for $var in $args.requireds.usedVariables
      $ftgWrite($var)#end for
  
    ! OPTIONAL ARGUMENTS
    #for $arg in $args.optionals
      #if $arg.usedVariables
        IF (PRESENT($arg.name)) THEN
        #for $var in $arg.usedVariables
          $ftgWrite($var)#end for 
        END IF
      #end if 
    #end for
  
    ! GLOBALS
    #for $var in $globals.usedVariables
      $ftgWrite($var)#end for

    CALL ftg_write("ftg_${subroutine.name}_round", ftg_${subroutine.name}_round)

    CALL ftg_destroy_savepoint()
    WRITE (0,*) 'FTG FINALIZE INPUT DATA ${subroutine.name}', my_mpi_id
    CALL ftg_destroy_serializer()

  END IF

END SUBROUTINE ftg_${subroutine.name}_capture_input

LOGICAL FUNCTION ftg_${subroutine.name}_capture_output_active()

  ftg_${subroutine.name}_capture_output_active =       &
    ftg_${subroutine.name}_capture_output_enabled .AND.  &
    ftg_${subroutine.name}_round .EQ. ftg_${subroutine.name}_capture_round

END FUNCTION ftg_${subroutine.name}_capture_output_active
  
SUBROUTINE ftg_${subroutine.name}_capture_output($commaList($args.allOut, $subroutine.result))

  USE mpi
  USE m_ser_ftg, ONLY: ftg_set_savepoint, ftg_write, ftg_register_only, ftg_destroy_savepoint, ftg_destroy_serializer

  ${globals.imports}

  ${args.allOut.specs(intent = 'in', allocatable = False)}
  #if $subroutine.isFunction:
    ${subroutine.result.spec(intent = 'in', allocatable = False)}
  #end if

  INTEGER(kind=4) my_mpi_id, error
  INTEGER :: ftg_d1, ftg_d2, ftg_d3, ftg_d4
  CHARACTER(len=256) :: ftg_c

  IF (ftg_${subroutine.name}_capture_output_active()) THEN

    CALL MPI_COMM_RANK(MPI_COMM_WORLD, my_mpi_id, error)
    CALL ftg_${subroutine.name}_init_for_capture('output', ftg_${subroutine.name}_output_dir)
    CALL ftg_set_savepoint('output')

    WRITE (0,*) 'FTG ROUND ${subroutine.name} ', ftg_${subroutine.name}_round, my_mpi_id
    WRITE (0,*) 'FTG WRITE output DATA ${subroutine.name}', my_mpi_id

    $resetRegistrations
    ! REQUIRED ARGUMENTS
    #for $var in $args.allOut.requireds.usedVariables
      $ftgWrite($var)#end for
      
    ! OPTIONAL ARGUMENTS
    #for $arg in $args.allOut.optionals
      #if $arg.usedVariables
        IF (PRESENT($arg.name)) THEN
          #for $var in $arg.usedVariables
            $ftgWrite($var)#end for 
        END IF
      #end if 
    #end for
    
    #if $subroutine.isFunction
      ! RESULT
      #for $var in $subroutine.result.usedVariables
        $ftgWrite($var)#end for
    #end if
    
    ! GLOBALS
    #for $var in $globals.usedVariables
      $ftgWrite($var)#end for
    
    CALL ftg_write("ftg_${subroutine.name}_round", ftg_${subroutine.name}_round)

    CALL ftg_destroy_savepoint()
    WRITE (0,*) 'FTG FINALIZE output DATA ${subroutine.name}', my_mpi_id
    CALL ftg_destroy_serializer()
    
    CALL MPI_BARRIER (MPI_COMM_WORLD, error)
    STOP 'FTG STOP'

  END IF

END SUBROUTINE ftg_${subroutine.name}_capture_output
  
$epilogue