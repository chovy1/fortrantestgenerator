#def ftg_write($var)
  #if $isReferencable($var)
    #if $containerNeedsRegistration($var)
      #for $level in $levels($var)[:-1]
        #set $container = $getExpression($var, $level)
        #set $contType = $type($container)
        #set $contDim = $dim($container)
        #if $needsRegistration($container)
          #if $isArray($container)
            CALL fs_register_derived_type_field(serializer, "$container", "$contType", LBOUND($container), UBOUND($container))$setRegistered($container)
          #else
            CALL fs_register_derived_type_field(serializer, "$container", "$contType")$setRegistered($container)
          #end if $setRegistered($container) 
        #end if
      #end for
    #end if
    #set $aa = $allocatedOrAssociated($var, 0)
    #if $aa != ''
      IF ($aa) THEN
    #end if
    #if $isArray($var)
      CALL fs_write_field(serializer, savepoint, "$var", $var, LBOUND($var), UBOUND($var))
    #else
      CALL fs_write_field(serializer, savepoint, "$var", $var)
    #end if  
    #if $aa != ''
      END IF
    #end if
  #else
  
    #set $mandDims = $getNumberOfMandatoryDimensions($var)
    #set $topContainer = $var
    #set $aa = '' 
    #set $ifAA = ''
    #for $d in range(1, $mandDims + 1)
      #set $topContainer = $getContainer($var, $d)
      #for $level in $levels($topContainer)
        #set $container = $getExpression($topContainer, $level)
        #set $contType = $type($container)
        #set $contDim = $dim($container)
        #if $needsRegistration($container)
          #set $filledContainer = $fillIndices($container, $d - 1, "ftg_d1", "ftg_d2", "ftg_d3", "ftg_d4")
          $writeVarNameWithFilledIndicesToString($container, "ftg_c", $d - 1, "ftg_d1", "ftg_d2", "ftg_d3", "ftg_d4")
          #if ($d - 1) < $totalDim($container)
            CALL fs_register_derived_type_field(serializer, ftg_c, "$contType", LBOUND($filledContainer), UBOUND($filledContainer))$setRegistered($container)
          #else
            CALL fs_register_derived_type_field(serializer, ftg_c, "$contType")$setRegistered($container)
          #end if 
        #end if
      #end for
      #set $aaNew = $allocatedOrAssociated($var, $d, "ftg_d1", "ftg_d2", "ftg_d3", "ftg_d4")
      #if $aaNew != $aa
        IF ($aaNew) THEN
        #set $ifAA += '1' 
        #set $aa = $aaNew 
      #else
        #set $ifAA += '0'
      #end if
      DO ftg_d$d = $lbound($var, $d, "ftg_d1", "ftg_d2", "ftg_d3", "ftg_d4"), $ubound($var, $d, "ftg_d1", "ftg_d2", "ftg_d3", "ftg_d4")
    #end for
    #for $level in sorted(set($levels($var)[:-1]) - set($levels($topContainer)))
      #set $container = $getExpression($var, $level)
      #set $contType = $type($container)
      #set $contDim = $dim($container)
      #if $needsRegistration($container)
        $writeVarNameWithFilledIndicesToString($container, "ftg_c", $d, "ftg_d1", "ftg_d2", "ftg_d3", "ftg_d4")        
        #if $d < $totalDim($container)
          #set $filledContainer = $fillIndices($container, $d, "ftg_d1", "ftg_d2", "ftg_d3", "ftg_d4")
          CALL fs_register_derived_type_field(serializer, ftg_c, "$contType", LBOUND($filledContainer), UBOUND($filledContainer))$setRegistered($container)
        #else
          CALL fs_register_derived_type_field(serializer, ftg_c, "$contType")$setRegistered($container)
        #end if 
      #end if
    #end for
    $writeVarNameWithFilledIndicesToString($var, "ftg_c", $mandDims, "ftg_d1", "ftg_d2", "ftg_d3", "ftg_d4")
    #set $filled = $fillIndices($var, $mandDims, "ftg_d1", "ftg_d2", "ftg_d3", "ftg_d4")
    #if $mandDims < $totalDim($var)
      CALL fs_write_field(serializer, savepoint, ftg_c, $filled, LBOUND($filled), UBOUND($filled))
    #else
      CALL fs_write_field(serializer, savepoint, ftg_c, $filled)
    #end if
    #for $d in range(1, $getNumberOfMandatoryDimensions($var) + 1)
      END DO
      #if $ifAA[-1] == '1'
        END IF
      #end if
      #set $ifAA = $ifAA[:-1]
    #end for
  #end if
#end def
################################################################################
  ! ================= BEGIN FORTRAN TEST GENERATOR (FTG) =======================
  
  SUBROUTINE ftg_${subroutine.name}_init_for_capture(serializer, stage, dir)

    USE mpi
    USE m_serialize,       ONLY: t_serializer, fs_create_serializer, fs_add_serializer_metainfo

    TYPE(t_serializer), INTENT(INOUT) :: serializer
    CHARACTER(*), INTENT(IN) :: stage, dir

    INTEGER (kind=4) my_mpi_id, error
    CHARACTER(len=MAX_CHAR_LENGTH) :: basename
    
    CALL MPI_COMM_RANK(MPI_COMM_WORLD, my_mpi_id, error)

    WRITE (basename,'(a,a,a,i0)') 'ftg_${subroutine.name}_', TRIM(stage), '_', my_mpi_id

    WRITE (0,*) 'FTG INIT ${subroutine.name} '//TRIM(basename), my_mpi_id
    CALL fs_create_serializer(TRIM(dir), TRIM(basename), 'w', serializer)
    CALL fs_add_serializer_metainfo(serializer, 'subroutine', '${subroutine.name}')
    CALL fs_add_serializer_metainfo(serializer, 'stage', stage)
    CALL fs_add_serializer_metainfo(serializer, 'mpi_id', my_mpi_id)

  END SUBROUTINE ftg_${subroutine.name}_init_for_capture

  LOGICAL FUNCTION ftg_${subroutine.name}_capture_input_active()

    ftg_${subroutine.name}_capture_input_active =       &
      ftg_${subroutine.name}_capture_input_enabled .AND.  &
      ftg_${subroutine.name}_round .EQ. ftg_${subroutine.name}_capture_round

  END FUNCTION ftg_${subroutine.name}_capture_input_active
    
  SUBROUTINE ftg_${subroutine.name}_capture_input(${arguments.all.names})

    USE mpi
    USE m_serialize, ONLY: t_serializer, t_savepoint, fs_create_savepoint, fs_add_savepoint_metainfo, fs_write_field, fs_destroy_savepoint, fs_destroy_serializer, fs_register_derived_type_field
    
    ${globals.imports}

    ${arguments.all.specifications(intent = 'in')}

    TYPE(t_serializer) :: serializer
    TYPE(t_savepoint)  :: savepoint
    
    INTEGER (kind=4) my_mpi_id, error
    INTEGER :: ftg_d1, ftg_d2, ftg_d3, ftg_d4
    CHARACTER(len=256) :: ftg_c

    IF (ftg_${subroutine.name}_capture_input_active()) THEN
      
      CALL MPI_COMM_RANK(MPI_COMM_WORLD, my_mpi_id, error)
      CALL ftg_${subroutine.name}_init_for_capture(serializer, 'input', ftg_${subroutine.name}_input_dir)
      CALL fs_create_savepoint('input', savepoint)

      WRITE (0,*) 'FTG ROUND ${subroutine.name} ', ftg_${subroutine.name}_round, my_mpi_id
      WRITE (0,*) 'FTG WRITE INPUT DATA ${subroutine.name}', my_mpi_id

      ! BASIC ARGUMENTS
      #for $var in $arguments.all.basic
      $ftg_write($var)#end for
      
      ! OPTIONAL ARGUMENTS
      #for $var in $arguments.all.optional
      IF (PRESENT($var)) THEN
        $ftg_write($var) END IF 
      #end for
      
      ! TYPE MEMBERS
      #for $var in $arguments.all.usedTypeMembers
      $ftg_write($var)#end for
      
      ! GLOBALS
      #for $var in $globals.usedVariables
      $ftg_write($var)#end for

      CALL fs_write_field(serializer, savepoint, "ftg_${subroutine.name}_round", ftg_${subroutine.name}_round)

      CALL fs_destroy_savepoint(savepoint)
      WRITE (0,*) 'FTG FINALIZE INPUT DATA ${subroutine.name}', my_mpi_id
      CALL fs_destroy_serializer(serializer)

    END IF

  END SUBROUTINE ftg_${subroutine.name}_capture_input

  LOGICAL FUNCTION ftg_${subroutine.name}_capture_output_active()

    ftg_${subroutine.name}_capture_output_active =       &
      ftg_${subroutine.name}_capture_output_enabled .AND.  &
      ftg_${subroutine.name}_round .EQ. ftg_${subroutine.name}_capture_round

  END FUNCTION ftg_${subroutine.name}_capture_output_active
    
  SUBROUTINE ftg_${subroutine.name}_capture_output(${arguments.output.names})

    USE mpi
    USE m_serialize, ONLY: t_serializer, t_savepoint, fs_create_savepoint, fs_add_savepoint_metainfo, fs_write_field, fs_destroy_savepoint, fs_destroy_serializer, fs_register_derived_type_field

    ${globals.imports}

    ${arguments.output.specifications(intent = 'in')}

    TYPE(t_serializer) :: serializer
    TYPE(t_savepoint)  :: savepoint
    
    INTEGER (kind=4) my_mpi_id, error
    INTEGER :: ftg_d1, ftg_d2, ftg_d3, ftg_d4
    CHARACTER(len=256) :: ftg_c

    IF (ftg_${subroutine.name}_capture_output_active()) THEN

      CALL MPI_COMM_RANK(MPI_COMM_WORLD, my_mpi_id, error)
      CALL ftg_${subroutine.name}_init_for_capture(serializer, 'output', ftg_${subroutine.name}_output_dir)
      CALL fs_create_savepoint('output', savepoint)

      WRITE (0,*) 'FTG ROUND ${subroutine.name} ', ftg_${subroutine.name}_round, my_mpi_id
      WRITE (0,*) 'FTG WRITE output DATA ${subroutine.name}', my_mpi_id

      $resetRegistrations
      ! BASIC ARGUMENTS
      #for $var in $arguments.output.basic
      $ftg_write($var)#end for
      
      ! OPTIONAL ARGUMENTS
      #for $var in $arguments.output.optional
      IF (PRESENT($var)) THEN
        $ftg_write($var) END IF 
      #end for
      
      ! TYPE MEMBERS
      #for $var in $arguments.output.usedTypeMembers
      $ftg_write($var)#end for
      
      ! GLOBALS
      #for $var in $globals.usedVariables
      $ftg_write($var)#end for
      
      CALL fs_write_field(serializer, savepoint, "ftg_${subroutine.name}_round", ftg_${subroutine.name}_round)

      CALL fs_destroy_savepoint(savepoint)
      WRITE (0,*) 'FTG FINALIZE output DATA ${subroutine.name}', my_mpi_id
      CALL fs_destroy_serializer(serializer)

    END IF

  END SUBROUTINE ftg_${subroutine.name}_capture_output
    
  ! ================= END FORTRAN TEST GENERATOR (FTG) =========================  